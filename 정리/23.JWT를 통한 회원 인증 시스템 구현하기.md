# 23. JWT를 통한 회원 인증 시스템 구현하기
## 23.1 JWT의 이해
JWT는 JSON Web Token의 약자로 데이터가 JSON으로 이루어져 있는 토큰을 의미한다.

### 세션 기반 인증과 토큰 기반 인증의 차이
사용자의 로그인 상태를 서버에서 처리하는 데 사용할 수 있는 대표적인 인증 방식으로

__1)세션 기반 인증 시스템__ : 사용자가 로그인을 하면, 세션 저장소에 사용자의 정보를 조회하고 `세션id`를 발급한다. 발급된 id는 브라우저의 쿠키에 저장하고 사용자가 다른 요청을 보낼 때마다 서버는 세션 저장소에서
세션을 조회한 후 로그인 여부를 결정하여 작업을 처리하고 응답을 한다. 세션 저장소는 주로 메모리, 디스크, 데이터베이스 등을 사용한다.

단점으로는 서버를 확장하기가 번거로워질 수 있고, 서버의 인스턴스가 여러 개가 된다면 모든 서버끼리 같은 세션을 공유해야 하므로 세션 전용 데이터베이스를 만들어야 한다.

__2)토큰 기반 인증 시스템__ : 토큰은 로그인 이후 서버가 만들어 주는 <u>문자열</u>이다. 문자열 안에는 사용자의 `로그인 정보`가 들어 있고, 해당 정보가 서버에서 발급되었음을 증명하는 `서명`이 들어있다.
이 토큰은 서명이 있기 때문에 무결성이 보장되고 이는 변경되거나 위조되지 않았음을 의미하는 성질이다.

사용자가 로그인을 하면 서버에서 사용자에게 토큰을 발급하고, 추후 사용자가 API를 요청하게 될 때 발급받은 토큰과 함께 요청하게 된다. 그러면 서버는 해당 토큰이 유효한지 검사하고, 결과에 따라 작업을 처리하고 응답한다.

토큰 기반 인증 방식의 장점은 서버에서 사용자 로그인 정보를 기억하기 위해 사용하는 리소스가 적고, 서버의 확장성이 매우 높다는 점이다.

## 23.2 User 스키마/모델 만들기
사용자의 정보를 담을 User 스키마와 모델을 생성한다. 사용자의 계정명과 비밀번호가 필요한데 비밀번호의 경우 아무런 가공도 하지 않은 텍스트로 저장시 보안상 매우 위험하다. 따라서 단방향 해시 함수를 지원해주는 bcrypt 라이브러리를 사용하여 비밀번호를 안전하게 저장하도록 한다.

`yarn add bcrypt`

```javascript
//src/models/user.js
import mongoose, { Schema } from 'mongoose';
import bcrypt from 'bcrypt';

const UserSchema = new Schema({
  username: String,
  hashedPassword: String,
});
// 인스턴스 메서드 생성, 화살표 함수가 아닌 function 키워드를 사용하여 구현한다. 이유는 this에 접근하기 위해서
// 비밀번호 설정
UserSchema.methods.setPassword = async function (password) {
  const hash = await bcrypt.hash(password, 10);
  this.hashedPassword = hash;
};
// 비밀번호가 일치하는지 검증
UserSchema.methods.checkPassword = async function (password) {
  const result = await bcrypt.compare(password, this.hashedPassword);
  return result;
};

// 스태틱 메서드 생성
// 스태틱 메서드 내에서 this는 모델을 가리킨다.
UserSchema.statics.findByUsername = function (username) {
  return this.findOne({ username });
};

const User = mongoose.model('User', UserSchema);
export default User;
```

## 23.3 회원 인증 API 만들기
```javascript
//src/api/auth/auth.ctrl.js
export const register = async (ctx) => {
  //회원가입
};

export const login = async (ctx) => {
  //로그인
};

export const check = async (ctx) => {
  //로그인 상태 확인
};

export const logout = async ctx => {
  //로그아웃
};
```
```javascript
//src/api/auth/index.js
import Router from 'koa-router';
import * as authCtrl from './auth.ctrl';

const auth = new Router();

auth.post('/register', authCtrl.register);
auth.post('/login', authCtrl.login);
auth.get('/check', authCtrl.check);
auth.post('logout', authCtrl.logout);

export default auth;
```
```javascript
//src/api/index.js
import Router from 'koa-router';
import posts from './posts';
import auth from './auth';

const api = new Router();

api.use('/posts', posts.routes());
api.use('/auth', auth.routes());

export default api;
```

### 회원가입 구현하기
```javascript
import Joi from 'joi';
import User from '../../models/user';

/*
  POST /api/auth/register
  {
    username: 'velopert',
    password: 'mypass123'
  }
 */
//회원가입
export const register = async (ctx) => {
  //Request Body 검증하기
  const schema = Joi.object().keys({
    username: Joi.string().alphanum().min(3).max(20).required(),
    password: Joi.string().required(),
  });
  const result = schema.validate(ctx.request.body);
  if (result.error) {
    ctx.status = 400;
    ctx.body = result.error;
    return;
  }

  const { username, password } = ctx.request.body;
  try {
    //username이 이미 존재하는지 확인인
    const exists = await User.findByUsername(username);
    if (exists) {
      ctx.status = 409;
      return;
    }

    const user = new User({
      username,
    });
    await user.setPassword(password); //비밀번호 설정
    await user.save(); //데이터베이스에 저장

    //이부분은 자주 사용하게 되므로 따로 serialize라는 인스턴스 함수로 만든다.
    // const data = user.toJSON();
    // delete data.hashedPassword;
    // ctx.body = data;
    ctx.body = user.serialize();
  } catch (e) {
    ctx.throw(500, e);
  }
};
```

### 로그인 구현하기
```javascript
/*
  POST /api/auth/login
  {
    username: 'velopert',
    password: 'mypass123'
  }
 */
//로그인
export const login = async (ctx) => {
  const { username, password } = ctx.request.body;

  //username, password가 없으면 에러 처리
  if (!username || !password) {
    ctx.status = 401;
    return;
  }

  try {
    const user = await User.findByUsername(username);
    //계정이 존재하지 않으면 에러 처리
    if (!user) {
      ctx.status = 401;
      return;
    }
    const valid = await user.checkPassword(password);
    //잘못된 비밀번호
    if (!valid) {
      ctx.status = 401;
      return;
    }
    ctx.body = user.serialize();
  } catch (e) {
    ctx.throw(500, e);
  }
};
```