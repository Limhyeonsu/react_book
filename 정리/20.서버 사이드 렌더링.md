# 20. 서버 사이드 렌더링
## 20.1 서버 사이드 렌더링의 이해
* 서버 사이드 렌더링 : UI를 서버에서 렌더링하는 것
* 클라이언트 사이드 렌더링 : UI 렌더링을 브라우저에서 처리, 자바스크립트를 실행해야 화면이 보인다.

### 서버 사이드 렌더링의 장점
1) 검색 엔진이 페이지의 내용을 제대로 수집해 갈 수 있다. (웹 서비스의 검색 엔진 최적화의 좋다)
2) 초기 렌더링 성능을 개선할 수 있다.

### 서버 사이드 렌더링의 단점
1) 브라우저가 해야 할 일을 서버가 대신 처리하는 것이므로 서버 리소스가 사용된다.(많은 사용자가 동시 접속시 서버 과부하 발생)
2) 프로젝트의 구조가 복잡해지고, 데이터 미리 불러오기, 코드 스플리팅과 호환 등 고려할 사항이 더 많아져 개발이 어려워질 수 있다.

서버 사이드 렌더링과 코드 스플리팅을 함께 적용하면서 별도의 호환 작업이 없으면 화면 깜빡임 현상이 발생한다. 이러한 문제점을 해결하기 위해 Loadable Components 라이브러리에서 제공하는 기능을 사용하여
서버 사이드 렌더링 후 필요한 파일의 경로를 추출하여 렌더링 결과에 스크립트/스타일 태그를 삽입해 주는 방법이 있다.

## 20.2 프로젝트 준비하기
`yarn add react-router-dom` 설치
```css
/* components/Blue.css */
.Blue {
    background: blue;
    font-size: 1.5rem;
    color: white;
    width: 128px;
    height: 128px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* components/Red.css */
.Red {
    background: red;
    font-size: 1.5rem;
    color: white;
    width: 128px;
    height: 128px;
    display: flex;
    align-items: center;
    justify-content: center;
}
```
```javascript
//components/Blue.js
import './Blue.css';
const Blue = () => {
  return <div className="Blue">Blue</div>;
};
export default Blue;

//components/Red.js
import './Red.css';
const Red = () => {
  return <div className="Red">Red</div>;
};
export default Red;

//components/Menu.js
import {Link} from 'react-router-dom';
const Menu = () => {
  return (
    <ul>
      <li>
        <Link to="/red">Red</Link>
      </li>
      <li>
        <Link to="/blue">Blue</Link>
      </li>
    </ul>
  );
};
export default Menu;
```
```javascript
//pages/BluePage.js
import Blue from '../components/Blue';
const BluePage = () => {
  return <Blue />;
};
export default BluePage;

//pages/RedPage.js
import Red from '../components/Red';
const RedPage = () => {
  return <Red />;
};
export default RedPage;
```
```javascript
//App.js
import BluePage from './pages/BluePage';
function App() {
  return (
    <div>
      <Menu />
      <hr />
      <Route path="/red" component={RedPage} />
      <Route path="/blue" component={BluePage} />
    </div>
  );
}
export default App;

//index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import {BrowserRouter} from 'react-router-dom';

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById('root')
);
```
## 20.3 서버 사이드 렌더링 구현하기
서버 사이드 렌더링 구현시 웹팩 설정을 커스터마이징해야 한다. 웹팩 관련 설정은 모두 숨겨져 있으니 `yarn eject` 명령어를 실행하여 밖으로 꺼내주어야 한다.(git 변경 파일 있으면 모두 커밋 후에!)

### 서버 사이드 렌더링용 엔트리 만들기
엔트리는 웹팩에서 프로젝트를 불러올 때 가장 먼저 불러오는 파일이다. 서버 사이드 렌더링시 서버를 위한 엔트리 파일을 따로 생성해야 한다.   
서버에서 리액트 컴포넌트를 렌더링할 때는 ReactDOMServer의 renderToString 함수를 사용한다. 이 함수에 JSX를 넣어서 호출시 렌더링 결과를 문자열로 반환한다.
```javascript
//index.server.js
import ReactDOMServer from 'react-dom/server';
const html = ReactDOMServer.renderToString(<div>Hello Server Side Rendering!</div>);
console.log(html);
```
[웹팩 환경설정]   
1)path설정
```javascript
//config/paths.js의 설정파일 수정
(...)
// config after eject: we're in ./config/
module.exports = {
  dotenv: resolveApp('.env'),
  appPath: resolveApp('.'),
  appBuild: resolveApp(buildPath),
  appPublic: resolveApp('public'),
  appHtml: resolveApp('public/index.html'),
  appIndexJs: resolveModule(resolveApp, 'src/index'),
  appPackageJson: resolveApp('package.json'),
  appSrc: resolveApp('src'),
  appTsConfig: resolveApp('tsconfig.json'),
  appJsConfig: resolveApp('jsconfig.json'),
  yarnLockFile: resolveApp('yarn.lock'),
  testsSetup: resolveModule(resolveApp, 'src/setupTests'),
  proxySetup: resolveApp('src/setupProxy.js'),
  appNodeModules: resolveApp('node_modules'),
  appWebpackCache: resolveApp('node_modules/.cache'),
  appTsBuildInfoFile: resolveApp('node_modules/.cache/tsconfig.tsbuildinfo'),
  swSrc: resolveModule(resolveApp, 'src/service-worker'),
  ssrIndexJs: resolveApp('src/index.server.js'),  //추가) 서버 사이드 렌더링 엔트리
  ssrBuild: resolveApp('dist'),                   //추가) 웹팩 처리 후 결과물 저장 경로
  publicUrlOrPath,
};
```
2)웹팩 환경설정 파일 작성
```javascript
//config/webpack.config.server.js 생성
const paths = require('./paths');

module.exports = {
  mode: 'production',       //프로덕션 모드로 설정 -> 최적화 옵션들 활성화
  entry: paths.ssrIndexJs,  //엔트리 경로
  target: 'node',           //node 환경에서 실행될 것이라고 명시
  output: {
    path: paths.ssrBuild,   //빌드 경로
    filename: 'server.js',  //파일 이름
    chunkFilename: 'js/[name].chunk.js',  //청크 파일 이름
    publicPath: paths.publicUrlOrPath     //정적 파일이 제공될 경로
  }
};
```
3)로더 설정
```javascript
//config/webpack.config.server.js 추가
const paths = require('./paths');
const getCSSModuleLocalIdent = require('react-dev-utils/getCSSModuleLocalIdent');
const cssRegex = /\.css$/;
const cssModuleRegex = /\.module\.css$/;
const sassRegex = /\.(scss|sass)$/;
const sassModuleRegex = /\.module\.(scss|sass)$/;

module.exports = {
  mode: 'production',
  entry: paths.ssrIndexJs,
  target: 'node',
  output: {
    path: paths.ssrBuild,
    filename: 'server.js',
    chunkFilename: 'js/[name].chunk.js',
    publicPath: paths.publicUrlOrPath
  },
  module: {
    rules: [
      {
        oneOf: [
          {
            //기존 webpack.config.js를 참고하여 작성
            test: /\.(js|mjs|jsx|ts|tsx)$/,
            include: paths.appSrc,
            loader: require.resolve('babel-loader'),
            options: {
              customize: require.resolve('babel-preset-react-app/webpack-overrides'),
              presets: [
                [
                  require.resolve('babel-preset-react-app'),
                  {
                    runtime: 'automatic'
                  }
                ]
              ],
              plugins: [
                [
                  require.resolve('babel-plugin-named-asset-import'),
                  {
                    loaderMap: {
                      svg: {
                        ReactComponent: '@svgr/webpack?-svgo,+titleProp,+ref![path]'
                      }
                    }
                  }
                ]
              ],
              cacheDirectory: true,
              cacheCompression: false,
              compact: false
            }
          },
          //CSS를 위한 처리
          {
            test: cssRegex,
            exclude: cssModuleRegex,
            loader: require.resolve('css-loader'),
            options: {
              importLoaders: 1,
              modules: {
                exportOnlyLocals: true //true로 설정시 실제 css파일을 생성하지 않는다.
              }
            }
          },
          //CSS Module을 위한 처리
          {
            test: cssModuleRegex,
            loader: require.resolve('css-loader'),
            options: {
              importLoaders: 1,
              modules: {
                exportOnlyLocals: true,
                getLocalIdent: getCSSModuleLocalIdent
              }
            }
          },
          //Sass를 위한 처리
          {
            test: sassRegex,
            exclude: sassModuleRegex,
            use: [
              {
                loader: require.resolve('css-loader'),
                options: {
                  importLoaders: 3,
                  modules: {
                    exportOnlyLocals: true
                  }
                }
              },
              require.resolve('sass-loader')
            ]
          },
          //Sass + CSS Module을 위한 처리
          {
            test: sassRegex,
            exclude: sassModuleRegex,
            use: [
              {
                loader: require.resolve('css-loader'),
                options: {
                  importLoaders: 3,
                  modules: {
                    exportOnlyLocals: true,
                    getLocalIdent: getCSSModuleLocalIdent
                  }
                }
              },
              require.resolve('sass-loader')
            ]
          },
          //url-loader를 위한 설정
          {
            test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
            loader: require.resolve('url-loader'),
            options: {
              emitFile: false,
              limit: 10000,
              name: 'static/media/[name].[hash:8].[ext]'
            }
          },
          {
            loader: require.resolve('file-loader'),
            exclude: [/\.(js|mjs|jsx|ts|tsx)$/, /\.html$/, /\.json$/],
            options: {
              emitFile: false,
              name: 'static/media/[name].[hash:8].[ext],'
            }
          }
        ]
      }
    ]
  },
  //react, react-dom/server 같은 라이브러리를 import 할때 node_modules에서 찾아서 사용함
  resolve: {
    module: ['node_modules']
  }
};

```
브라우저에서 사용시 결과물 파일에 리액트 라이브러리와 애플리케이션에 관한 코드가 공존해야한다. 서버에서는 그러지 않아도 되는데 이유는 node_modules를 통해 바로 불러와 사용할 수 있기 때문이다.   
따라서 서버를 위해 번들링시에는 node_modules에서 불러오는 것을 제외하고 번들링 하는 것이 좋다. 이를 위해 `webpack-node-externals` 라이브러리를 사용한다.   
해당 라이브러리도 webpack.config.server.js에 적용하고, 환경변수를 주입한다.
```javascript
//config/webpack.config.server.js 추가
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const getClientEnvironment = require('./env');
const env = getClientEnvironment(paths.publicUrlOrPath.slice(0, -1));
(...)

module.exports = {
    (...)
    resolve: {
      module: ['node_modules']
    },
    externals: [
      nodeExternals({
        allowlist: [/@babel/]
      })
    ]
};
```