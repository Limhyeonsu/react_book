# 20. 서버 사이드 렌더링
## 20.1 서버 사이드 렌더링의 이해
* 서버 사이드 렌더링 : UI를 서버에서 렌더링하는 것
* 클라이언트 사이드 렌더링 : UI 렌더링을 브라우저에서 처리, 자바스크립트를 실행해야 화면이 보인다.

### 서버 사이드 렌더링의 장점
1) 검색 엔진이 페이지의 내용을 제대로 수집해 갈 수 있다. (웹 서비스의 검색 엔진 최적화의 좋다)
2) 초기 렌더링 성능을 개선할 수 있다.

### 서버 사이드 렌더링의 단점
1) 브라우저가 해야 할 일을 서버가 대신 처리하는 것이므로 서버 리소스가 사용된다.(많은 사용자가 동시 접속시 서버 과부하 발생)
2) 프로젝트의 구조가 복잡해지고, 데이터 미리 불러오기, 코드 스플리팅과 호환 등 고려할 사항이 더 많아져 개발이 어려워질 수 있다.

서버 사이드 렌더링과 코드 스플리팅을 함께 적용하면서 별도의 호환 작업이 없으면 화면 깜빡임 현상이 발생한다. 이러한 문제점을 해결하기 위해 Loadable Components 라이브러리에서 제공하는 기능을 사용하여
서버 사이드 렌더링 후 필요한 파일의 경로를 추출하여 렌더링 결과에 스크립트/스타일 태그를 삽입해 주는 방법이 있다.

## 20.2 프로젝트 준비하기
`yarn add react-router-dom` 설치
```css
/* components/Blue.css */
.Blue {
    background: blue;
    font-size: 1.5rem;
    color: white;
    width: 128px;
    height: 128px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* components/Red.css */
.Red {
    background: red;
    font-size: 1.5rem;
    color: white;
    width: 128px;
    height: 128px;
    display: flex;
    align-items: center;
    justify-content: center;
}
```
```javascript
//components/Blue.js
import './Blue.css';
const Blue = () => {
  return <div className="Blue">Blue</div>;
};
export default Blue;

//components/Red.js
import './Red.css';
const Red = () => {
  return <div className="Red">Red</div>;
};
export default Red;

//components/Menu.js
import {Link} from 'react-router-dom';
const Menu = () => {
  return (
    <ul>
      <li>
        <Link to="/red">Red</Link>
      </li>
      <li>
        <Link to="/blue">Blue</Link>
      </li>
    </ul>
  );
};
export default Menu;
```
```javascript
//pages/BluePage.js
import Blue from '../components/Blue';
const BluePage = () => {
  return <Blue />;
};
export default BluePage;

//pages/RedPage.js
import Red from '../components/Red';
const RedPage = () => {
  return <Red />;
};
export default RedPage;
```
```javascript
//App.js
import BluePage from './pages/BluePage';
function App() {
  return (
    <div>
      <Menu />
      <hr />
      <Route path="/red" component={RedPage} />
      <Route path="/blue" component={BluePage} />
    </div>
  );
}
export default App;

//index.js
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import {BrowserRouter} from 'react-router-dom';

ReactDOM.render(
  <BrowserRouter>
    <App />
  </BrowserRouter>,
  document.getElementById('root')
);
```
## 20.3 서버 사이드 렌더링 구현하기
서버 사이드 렌더링 구현시 웹팩 설정을 커스터마이징해야 한다. 웹팩 관련 설정은 모두 숨겨져 있으니 `yarn eject` 명령어를 실행하여 밖으로 꺼내주어야 한다.(git 변경 파일 있으면 모두 커밋 후에!)

### 서버 사이드 렌더링용 엔트리 만들기
엔트리는 웹팩에서 프로젝트를 불러올 때 가장 먼저 불러오는 파일이다. 서버 사이드 렌더링시 서버를 위한 엔트리 파일을 따로 생성해야 한다.   
서버에서 리액트 컴포넌트를 렌더링할 때는 ReactDOMServer의 renderToString 함수를 사용한다. 이 함수에 JSX를 넣어서 호출시 렌더링 결과를 문자열로 반환한다.
```javascript
//index.server.js
import ReactDOMServer from 'react-dom/server';
const html = ReactDOMServer.renderToString(<div>Hello Server Side Rendering!</div>);
console.log(html);
```

### 서버 사이드 렌더링 전용 웹팩 환경 설정 작성하기
1)path설정
```javascript
//config/paths.js의 설정파일 수정
(...)
// config after eject: we're in ./config/
module.exports = {
  dotenv: resolveApp('.env'),
  appPath: resolveApp('.'),
  appBuild: resolveApp(buildPath),
  appPublic: resolveApp('public'),
  appHtml: resolveApp('public/index.html'),
  appIndexJs: resolveModule(resolveApp, 'src/index'),
  appPackageJson: resolveApp('package.json'),
  appSrc: resolveApp('src'),
  appTsConfig: resolveApp('tsconfig.json'),
  appJsConfig: resolveApp('jsconfig.json'),
  yarnLockFile: resolveApp('yarn.lock'),
  testsSetup: resolveModule(resolveApp, 'src/setupTests'),
  proxySetup: resolveApp('src/setupProxy.js'),
  appNodeModules: resolveApp('node_modules'),
  appWebpackCache: resolveApp('node_modules/.cache'),
  appTsBuildInfoFile: resolveApp('node_modules/.cache/tsconfig.tsbuildinfo'),
  swSrc: resolveModule(resolveApp, 'src/service-worker'),
  ssrIndexJs: resolveApp('src/index.server.js'),  //추가) 서버 사이드 렌더링 엔트리
  ssrBuild: resolveApp('dist'),                   //추가) 웹팩 처리 후 결과물 저장 경로
  publicUrlOrPath,
};
```
2)웹팩 환경설정 파일 작성
```javascript
//config/webpack.config.server.js 생성
const paths = require('./paths');

module.exports = {
  mode: 'production',       //프로덕션 모드로 설정 -> 최적화 옵션들 활성화
  entry: paths.ssrIndexJs,  //엔트리 경로
  target: 'node',           //node 환경에서 실행될 것이라고 명시
  output: {
    path: paths.ssrBuild,   //빌드 경로
    filename: 'server.js',  //파일 이름
    chunkFilename: 'js/[name].chunk.js',  //청크 파일 이름
    publicPath: paths.publicUrlOrPath     //정적 파일이 제공될 경로
  }
};
```
3)로더 설정
```javascript
//config/webpack.config.server.js 추가
const paths = require('./paths');
const getCSSModuleLocalIdent = require('react-dev-utils/getCSSModuleLocalIdent');
const cssRegex = /\.css$/;
const cssModuleRegex = /\.module\.css$/;
const sassRegex = /\.(scss|sass)$/;
const sassModuleRegex = /\.module\.(scss|sass)$/;

module.exports = {
  mode: 'production',
  entry: paths.ssrIndexJs,
  target: 'node',
  output: {
    path: paths.ssrBuild,
    filename: 'server.js',
    chunkFilename: 'js/[name].chunk.js',
    publicPath: paths.publicUrlOrPath
  },
  module: {
    rules: [
      {
        oneOf: [
          {
            //기존 webpack.config.js를 참고하여 작성
            test: /\.(js|mjs|jsx|ts|tsx)$/,
            include: paths.appSrc,
            loader: require.resolve('babel-loader'),
            options: {
              customize: require.resolve('babel-preset-react-app/webpack-overrides'),
              presets: [
                [
                  require.resolve('babel-preset-react-app'),
                  {
                    runtime: 'automatic'
                  }
                ]
              ],
              plugins: [
                [
                  require.resolve('babel-plugin-named-asset-import'),
                  {
                    loaderMap: {
                      svg: {
                        ReactComponent: '@svgr/webpack?-svgo,+titleProp,+ref![path]'
                      }
                    }
                  }
                ]
              ],
              cacheDirectory: true,
              cacheCompression: false,
              compact: false
            }
          },
          //CSS를 위한 처리
          {
            test: cssRegex,
            exclude: cssModuleRegex,
            loader: require.resolve('css-loader'),
            options: {
              importLoaders: 1,
              modules: {
                exportOnlyLocals: true //true로 설정시 실제 css파일을 생성하지 않는다.
              }
            }
          },
          //CSS Module을 위한 처리
          {
            test: cssModuleRegex,
            loader: require.resolve('css-loader'),
            options: {
              importLoaders: 1,
              modules: {
                exportOnlyLocals: true,
                getLocalIdent: getCSSModuleLocalIdent
              }
            }
          },
          //Sass를 위한 처리
          {
            test: sassRegex,
            exclude: sassModuleRegex,
            use: [
              {
                loader: require.resolve('css-loader'),
                options: {
                  importLoaders: 3,
                  modules: {
                    exportOnlyLocals: true
                  }
                }
              },
              require.resolve('sass-loader')
            ]
          },
          //Sass + CSS Module을 위한 처리
          {
            test: sassRegex,
            exclude: sassModuleRegex,
            use: [
              {
                loader: require.resolve('css-loader'),
                options: {
                  importLoaders: 3,
                  modules: {
                    exportOnlyLocals: true,
                    getLocalIdent: getCSSModuleLocalIdent
                  }
                }
              },
              require.resolve('sass-loader')
            ]
          },
          //url-loader를 위한 설정
          {
            test: [/\.bmp$/, /\.gif$/, /\.jpe?g$/, /\.png$/],
            loader: require.resolve('url-loader'),
            options: {
              emitFile: false,
              limit: 10000,
              name: 'static/media/[name].[hash:8].[ext]'
            }
          },
          {
            loader: require.resolve('file-loader'),
            exclude: [/\.(js|mjs|jsx|ts|tsx)$/, /\.html$/, /\.json$/],
            options: {
              emitFile: false,
              name: 'static/media/[name].[hash:8].[ext],'
            }
          }
        ]
      }
    ]
  },
  //react, react-dom/server 같은 라이브러리를 import 할때 node_modules에서 찾아서 사용함
  resolve: {
    module: ['node_modules']
  }
};

```
브라우저에서 사용시 결과물 파일에 리액트 라이브러리와 애플리케이션에 관한 코드가 공존해야한다. 서버에서는 그러지 않아도 되는데 이유는 node_modules를 통해 바로 불러와 사용할 수 있기 때문이다.   
따라서 서버를 위해 번들링시에는 node_modules에서 불러오는 것을 제외하고 번들링 하는 것이 좋다. 이를 위해 `webpack-node-externals` 라이브러리를 사용한다.   
해당 라이브러리도 webpack.config.server.js에 적용하고, 환경변수를 주입한다.
```javascript
//config/webpack.config.server.js 추가
const nodeExternals = require('webpack-node-externals');
const webpack = require('webpack');
const getClientEnvironment = require('./env');
const env = getClientEnvironment(paths.publicUrlOrPath.slice(0, -1));
(...)

module.exports = {
    (...)
    resolve: {
      module: ['node_modules']
    },
    externals: [
      nodeExternals({
        allowlist: [/@babel/]
      })
    ]
};
```

### 빌드 스크립트 작성하기
웹팩으로 프로젝트를 빌드하는 스크립트 작성한다. scripts/build.js 파일은 클라이언트에서 사용할 빌드 파일을 만드는 작업을 한다. 비슷한 형식으로 서버에서 사용할 빌드 파일을 만드는 build.server.js를 작성한다.
```javascript
//scripts/build.server.js
process.env.BABEL_ENV = 'production';
process.env.NODE_ENV = 'production';

process.on('unhandledRejection', (err) => {
  throw err;
});

require('../config/env');
const fs = require('fs-extra');
const webpack = require('webpack');
const config = require('../config/webpack.config.server');
const paths = require('../config/paths');

function build() {
  console.log('Creating server build...');
  fs.emptyDirSync(paths.ssrBuild);
  let compiler = webpack(config);
  return new Promise((resolve, reject) => {
    compiler.run((err, stats) => {
      if (err) {
        console.log(err);
        return;
      }
      console.log(stats.toString());
    });
  });
}

build();
```
작성 후 `node scripts/build.server.js` 명령어로 빌드가 잘 되는지 확인 -> `node dist/server.js`   
**Cannot find module 'url-loader' 발생하여 `yarn add url-loader` 먼저 다운 후 빌드함
```
//package.json
"scripts": {
  "start": "node scripts/start.js",
    "build": "node scripts/build.js",
    "test": "node scripts/test.js",
    "start:server": "node dist/server.js",
    "build:server": "node scripts/build.server.js"
}
```
package.json 설정을 통하여 명령어를 쉽게 입력할 수 있음

### 서버 코드 작성하기
Express라는 Node.js 웹 프레임워크를 사용한다. `yarn add express`
```javascript
//index.server.js
import ReactDOMServer from 'react-dom/server';
import express from 'express';
import {StaticRouter} from 'react-router-dom';
import App from './App';
import path from 'path';
import fs from 'fs';

//asset-manifest.json에서 파일 경로들을 조회한다.
const manifest = JSON.parse(fs.readFileSync(path.resolve('./build/asset-manifest.json'), 'utf8'));

//chunk.js로 끝나는 키를 찾아서 스크립트 태그로 변환
const chunks = Object.keys(manifest.files)
  .filter((key) => /chunk\.js$/.exec(key))
  .map((key) => `<script src="${manifest.files[key]}"></script>`)
  .join('');

function createPage(root) {
  return `<!DOCTYPE html>
  <html lang='en'>
  <head>
    <meta charset='utf-8' />
    <link rel='shortcut icon' href='/favicon.ico' />
    <meta
      name='viewport'
      content='width=device-width, initial-scale=1, shrink-to-fit=no'
    />
    <meta name='theme-color' content='#000000' />
    <title>React App</title>
    <link href="${manifest.files['main.css']}" rel='stylesheet' />
  </head>
  <body>
    <noscript> YOU need to enable JavaScript to run this app.</noscript>
    <div id='root'>
      ${root}
    </div>
    <script src='${manifest.files['runtime-main.js']}'></script>
    ${chunks}
    <script src='${manifest.files['main.js']}'></script>
  </body>
  </html>
  `;
}

const app = express();

//서버 사이드 렌더링을 처리할 핸들러 함수 
//404가 떠야하는 상황에서 404를 띄우지 않고 서버 사이드 렌더링을 해준다.
const serverRender = (req, res, next) => {
  const context = {};
  const jsx = (
    // StaticRouter는 주로 서버 사이드 렌더링 용도로 사용된다. props로 넣어주는 location 값에 따라 라우팅을 해주고, context는 렌더링한 컴포넌트에 따라 HTTP 상태 코드를 설정해 줄 수 있다.
    <StaticRouter location={req.url} context={context}>
      <App />
    </StaticRouter>
  );
  const root = ReactDOMServer.renderToString(jsx);
  res.send(createPage(root)); //클라이언트에게 결과물을 응답
};

const serve = express.static(path.resolve('./build'), {
  index: false // /경로에서 index.html을 보여주지 않도록 설정
});

app.use(serve);
app.use(serverRender);

//5000번 포트로 서도 가동
app.listen(5000, () => {
  console.log('Running on http://localhost:5000');
});
const html = ReactDOMServer.renderToString(<div>Hello Server Side Rendering!</div>);

console.log(html);
```
서버 사이드 렌더링을 구현하면 이렇게 첫 번째 렌더링은 서버를 통해 하지만, 그 이후에는 브라우저에서 처리한다.