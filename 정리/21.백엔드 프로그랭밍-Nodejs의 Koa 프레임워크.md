# 21. 백엔드 프로그래밍 : Node.js의 Koa 프레임워크
## 21.1 소개하기
### 백엔드
데이터 등록시 사용자 인증 정보가 필요할 수 있고, 데이터 검증, 데이터 구분 등을 고려해야 한다. 데이터 조회시엔 데이터를 몇 개씩 보여 줄지, 어떻게 보여 줄지 등의 로직을 만드는데 이를 서버 프로그래밍, 백엔드 프로그래밍이라고 한다.
백엔드 프로그래밍은 다양한 환경에서 언어에 구애 받지 않고 구현할 수 있다.

### Node.js
V8이라는 자바스크립트 엔진을 기반으로 웹 브라우저뿐만 아니라 서버에서도 자바 스크립트를 사용할 수 있는 런타임이 개발되었다. 이것이 `Node.js`이다.

### Koa
Node.js에서 웹 서버 구축시 보통 `Express, Hapi, Koa` 등의 웹 프레임워크를 사용한다.

Express는 미들웨어, 라우팅, 템플릿, 파일 호스팅 등과 같은 다양한 기능이 자체적으로 내장되어 있으나 Koa는 미들웨어 기능만 갖추고 있어 필요한 기능들만 붙여서 서버를 만들 수 있다. 그래서 Express보다 가볍다.

## 21.2 작업 환경 준비
1) 디렉토리 생성 blog > blog-backend > yarn init -y > yarn add koa
2) ESLint와 Prettier 설정 yarn --dev eslint > yarn run eslint --init > .eslintrc.json 파일 생성됨 / 디렉토리에 .prettierrc 파일 생성 > yarn add eslint-config-prettier

## 21.3 Koa 기본 사용법
### 서버 띄우기
```javascript
//src/index.js
const Koa = require('koa');

const app = new Koa();

//화면에 hello world 출력
app.use((ctx) => {
  ctx.body = 'hello world';
});

//4000번 포트로 서버 open
app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```
`node src` 명령어를 통해 서버 실행 (index.js 파일은 디렉터리까지만 입력해도 실행할 수 있다.)

### 미들웨어
Koa 애플리케이션은 미들웨어의 배열로 구성되어 있다. 위 코드에서 app.use 함수가 미들웨어 함수를 애플리케이션에 등록한다.

```javascript
/**
 * 미들웨어 함수의 구조
 * ctx : 웹 요청과 응답에 관한 정보를 가지고 있다. 
 * next : 현재 처리 중인 미들웨어의 다음 미들웨어를 호출하는 함수이다. 미들웨어에서 next를 사용하지 않는 경우 생략 가능
 */

(ctx, next) => { }
```

미들웨어는 app.use를 사용하여 등록되는 순서대로 처리된다.

```javascript
const Koa = require('koa');
const app = new Koa();

//1
app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  next();
});

//2
app.use((ctx, next) => {
  console.log(2);
  next();
});

//3
app.use((ctx) => {
  ctx.body = 'hello world';
});

app.listen(4000, () => {
  console.log('Listening to port 4000');
});
```
실행결과
```
Listening to port 4000
/
1
2
/favicon.ico
1
2
```

조건부로 미들웨어 처리를 무시할 수 있는데 다음의 코드는 요청 경로에 authorized=1 이라는 쿼리 파라미터가 포함되어 있으면 이후 미들웨어를 처리해 주고, 그렇지 않으면 이후 미들웨어를 처리하지 않는다.
```javascript
...

//http://localhost:4000/?authorized=1
app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401;
    return;
  }
  next();
});
...
```
__쿼리 파라미터는 문자열이기 때문에 비교할 때는 반드시 문자열 형태로 비교해야 한다.__

1. next 함수를 호출하면 Promise를 반환하고, 이 Promise는 다음에 처리해야 할 미들웨어가 끝나야 완료된다.

```javascript
app.use((ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401;
    return;
  }
  next().then(() => {
    console.log('END');
  });
});
```
실행결과
```
Listening to port 4000
/?authorized=1
1
2
END
/favicon.ico
1
```

2. async / await 사용하기
```javascript
app.use(async (ctx, next) => {
  console.log(ctx.url);
  console.log(1);
  if (ctx.query.authorized !== '1') {
    ctx.status = 401;
    return;
  }
  await next();
  console.log('END');
});
```

## 21.4 nodemon 사용하기
nodemon이라는 도구를 사용하면 코드를 변경할 때마다 서버를 자동으로 재시작해 준다. `yarn add --dev nodemon`

```
//package.json 에 추가
"scripts": {
    //서버 시작하는 명령어
    "start": "node src",
    //nodemon을 통해 서버를 실행해 주는 명령어로 src를 주시하고 있다가 디렉터리 내부의 파일이 변경되면 index.js 파일을 재시작한다.
    "start:dev": "nodemon --watch src/ src/index.js" 
  }
```